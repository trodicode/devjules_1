// js/stackby-api.js
// This file contains all functions for interacting with the Stackby API.

// --- Stackby Configuration ---
// IMPORTANT SECURITY WARNING: Embedding API keys directly in client-side JavaScript
// is insecure and should NOT be done in a production environment.
// This is done here only for the purpose of this exercise.
// In a real application, use a backend proxy or serverless functions to protect your API key.
const STACKBY_API_KEY = 'WX7IrHyKghNz8S7V';
const STACKBY_STACK_ID = 'ticketing'; // This is often the Stack's URL-friendly name or ID
const STACKBY_TABLE_NAME = 'tbase'; // The actual name of the table

// Base URL for Stackby API
const STACKBY_API_BASE_URL = 'https://api.stackby.com/v1/table';

// Column Name Mapping
// Using a mapping allows for easier updates if column names change in Stackby.
const COLUMN_NAMES = {
    TICKET_TITLE: 'Ticket Title',
    DETAILED_DESCRIPTION: 'Detailed Description',
    URGENCY_LEVEL: 'Urgency Level',
    ATTACHMENT: 'Attachment',
    TICKET_ID: 'Ticket ID', // This is usually auto-generated by Stackby (e.g., Autonumber or Row ID)
    STATUS: 'Status',
    ASSIGNED_COLLABORATOR: 'Assigned Collaborator',
    ROW_ID: 'rowId' // Placeholder for conceptual mapping, Stackby's rowId is top-level
};

// --- Helper Functions ---

/**
 * Generic helper function to make fetch requests to the Stackby API.
 * @param {string} endpoint - The API endpoint (e.g., '' for table, '/{rowId}' for specific row).
 * @param {string} method - HTTP method (GET, POST, PATCH, DELETE).
 * @param {object} [body=null] - Request body for POST/PATCH.
 * @returns {Promise<object|Array>} - A promise that resolves to the JSON response.
 */
async function _fetchStackbyAPI(endpoint, method, body = null) {
    const url = `${STACKBY_API_BASE_URL}/${STACKBY_STACK_ID}/${STACKBY_TABLE_NAME}${endpoint}`;
    
    const headers = {
        'Authorization': `Bearer ${STACKBY_API_KEY}`,
        'Content-Type': 'application/json'
    };

    const config = {
        method: method,
        headers: headers
    };

    if (body) {
        config.body = JSON.stringify(body);
    }

    console.log("[Stackby API] Request URL:", url);
    console.log("[Stackby API] Request Method:", config.method);
    console.log("[Stackby API] Request Headers:", JSON.stringify(config.headers));
    if (config.body) {
        console.log("[Stackby API] Request Body:", config.body);
    }

    try {
        const response = await fetch(url, config);

        console.log("[Stackby API] Response Status:", response.status);
        console.log("[Stackby API] Response Status Text:", response.statusText);
        console.log("[Stackby API] Response OK:", response.ok);

        // Clone the response to log its body, because the body can only be read once
        response.clone().json().then(data => {
            console.log("[Stackby API] Response Body (JSON):", data);
        }).catch(err => {
            response.clone().text().then(text => {
                console.log("[Stackby API] Response Body (Text):", text);
            });
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ message: response.statusText })); // Try to parse error as JSON
            console.error(`[Stackby API] API Error Response Data for ${method} ${url}:`, errorData);
            throw new Error(`Stackby API request failed with status ${response.status}: ${errorData.message || JSON.stringify(errorData)}`);
        }

        if (response.status === 204 || response.headers.get("content-length") === "0") {
            console.log("[Stackby API] Response is 204 No Content or empty.");
            return null; 
        }
        
        // If we expect JSON, we parse it here. The cloned response above is just for logging.
        const jsonData = await response.json();
        console.log("[Stackby API] Parsed JSON Data from response:", jsonData);
        return jsonData;

    } catch (error) {
        console.error(`[Stackby API] Fetch Error during API call to ${url}:`, error);
        console.error("[Stackby API] Error Name:", error.name);
        console.error("[Stackby API] Error Message:", error.message);
        throw error; // Re-throw to be caught by the calling function
    }
}

// --- Core API Functions ---

/**
 * Initializes the Stackby API configuration.
 */
function initStackby() {
    console.log("[Stackby API Init] Initializing Stackby API configuration...");
    console.log("[Stackby API Init] STACKBY_API_KEY (first 5 chars):", STACKBY_API_KEY ? STACKBY_API_KEY.substring(0, 5) + "..." : "Not Set");
    console.log("[Stackby API Init] STACKBY_STACK_ID:", STACKBY_STACK_ID);
    console.log("[Stackby API Init] STACKBY_TABLE_NAME:", STACKBY_TABLE_NAME);
    console.log("[Stackby API Init] COLUMN_NAMES Mapping:", JSON.stringify(COLUMN_NAMES, null, 2));

    if (STACKBY_API_KEY && STACKBY_STACK_ID && STACKBY_TABLE_NAME) {
        console.log('[Stackby API Init] Configuration appears to be loaded.');
    } else {
        console.error('[Stackby API Init] CRITICAL: Stackby API Key, Stack ID, or Table Name is missing.');
    }
}
// Call init for logging purposes when script loads
initStackby();


/**
 * Creates a new ticket in Stackby.
 */
async function createTicket(ticketData) {
    console.log("[Stackby API] createTicket called with data:", JSON.stringify(ticketData, null, 2));
    if (!STACKBY_API_KEY || !STACKBY_TABLE_NAME || !STACKBY_STACK_ID) {
        console.error('[Stackby API] createTicket: API not configured. Credentials missing.');
        return null;
    }

    const dataToCreate = {
        ...ticketData,
        [COLUMN_NAMES.STATUS]: 'New'
    };
    const requestBody = { fields: dataToCreate };

    try {
        console.log('[Stackby API] createTicket: Attempting to create ticket with processed data:', JSON.stringify(requestBody, null, 2));
        const createdRows = await _fetchStackbyAPI('', 'POST', requestBody);
        
        let result = null;
        if (createdRows && Array.isArray(createdRows) && createdRows.length > 0) {
            result = createdRows[0];
            console.log('[Stackby API] createTicket: Ticket created successfully. Result:', JSON.stringify(result, null, 2));
        } else {
            // Handle cases where Stackby might return a single object on creation, or other non-array formats
            if (createdRows && typeof createdRows === 'object' && createdRows.rowId) {
                 result = createdRows;
                 console.log('[Stackby API] createTicket: Ticket created successfully (returned single object). Result:', JSON.stringify(result, null, 2));
            } else {
                console.warn('[Stackby API] createTicket: Ticket creation returned an unexpected response format.', createdRows);
                result = createdRows; // Pass on the unexpected response
            }
        }
        return result;
    } catch (error) {
        console.error('[Stackby API] createTicket: Error during ticket creation.', error);
        return null;
    }
}

/**
 * Retrieves all tickets from Stackby.
 */
async function getAllTickets() {
    console.log("[Stackby API] getAllTickets called.");
    if (!STACKBY_API_KEY || !STACKBY_TABLE_NAME || !STACKBY_STACK_ID) {
        console.error('[Stackby API] getAllTickets: API not configured. Credentials missing.');
        return null;
    }

    try {
        const tickets = await _fetchStackbyAPI('', 'GET');
        console.log('[Stackby API] getAllTickets: Tickets fetched successfully. Count:', tickets ? tickets.length : 0);
        // console.log('[Stackby API] getAllTickets: Full response data:', JSON.stringify(tickets, null, 2)); // Potentially very verbose
        return tickets;
    } catch (error) {
        console.error('[Stackby API] getAllTickets: Error fetching tickets.', error);
        return null;
    }
}

/**
 * Retrieves a specific ticket by its Stackby Row ID.
 */
async function getTicketById(rowId) {
    console.log(`[Stackby API] getTicketById called with rowId: ${rowId}`);
    if (!STACKBY_API_KEY || !STACKBY_TABLE_NAME || !STACKBY_STACK_ID) {
        console.error('[Stackby API] getTicketById: API not configured. Credentials missing.');
        return null;
    }
    if (!rowId) {
        console.error('[Stackby API] getTicketById: Row ID is required.');
        return null;
    }

    try {
        const ticket = await _fetchStackbyAPI(`/${rowId}`, 'GET');
        console.log(`[Stackby API] getTicketById: Ticket ${rowId} fetched successfully. Result:`, JSON.stringify(ticket, null, 2));
        return ticket;
    } catch (error) {
        console.error(`[Stackby API] getTicketById: Error fetching ticket ${rowId}.`, error);
        return null;
    }
}

/**
 * Updates an existing ticket in Stackby using its Row ID.
 */
async function updateTicket(rowId, updatedData) {
    console.log(`[Stackby API] updateTicket called for rowId: ${rowId} with data:`, JSON.stringify(updatedData, null, 2));
    if (!STACKBY_API_KEY || !STACKBY_TABLE_NAME || !STACKBY_STACK_ID) {
        console.error('[Stackby API] updateTicket: API not configured. Credentials missing.');
        return null;
    }
    if (!rowId) {
        console.error('[Stackby API] updateTicket: Row ID is required.');
        return null;
    }

    const requestBody = { fields: updatedData };

    try {
        console.log(`[Stackby API] updateTicket: Attempting to update ticket ${rowId} with processed data:`, JSON.stringify(requestBody, null, 2));
        const updatedTicket = await _fetchStackbyAPI(`/${rowId}`, 'PATCH', requestBody);
        console.log(`[Stackby API] updateTicket: Ticket ${rowId} updated successfully. Result:`, JSON.stringify(updatedTicket, null, 2));
        return updatedTicket;
    } catch (error) {
        console.error(`[Stackby API] updateTicket: Error updating ticket ${rowId}.`, error);
        return null;
    }
}

console.log('[Stackby API] stackby-api.js loaded and initial configuration logged.');
