// js/stackby-api.js
// This file contains all functions for interacting with the Stackby API.

// --- Stackby Configuration ---
// IMPORTANT SECURITY WARNING: Embedding API keys directly in client-side JavaScript
// is insecure and should NOT be done in a production environment.
// This is done here only for the purpose of this exercise.
// In a real application, use a backend proxy or serverless functions to protect your API key.
const STACKBY_API_KEY = 'WX7IrHyKghNz8S7V';
const STACKBY_STACK_ID = 'ticketing'; // This is often the Stack's URL-friendly name or ID
const STACKBY_TABLE_NAME = 'tbase'; // The actual name of the table

// Base URL for Stackby API
const STACKBY_API_BASE_URL = 'https://api.stackby.com/v1/table';

// Column Name Mapping
// Using a mapping allows for easier updates if column names change in Stackby.
const COLUMN_NAMES = {
    TICKET_TITLE: 'Ticket Title',
    DETAILED_DESCRIPTION: 'Detailed Description',
    URGENCY_LEVEL: 'Urgency Level',
    ATTACHMENT: 'Attachment',
    TICKET_ID: 'Ticket ID', // This is usually auto-generated by Stackby (e.g., Autonumber or Row ID)
    STATUS: 'Status',
    ASSIGNED_COLLABORATOR: 'Assigned Collaborator',
    // Stackby's internal Row ID (not a column you create, but used in API calls)
    ROW_ID: 'rowId' // Placeholder, actual rowId comes from Stackby responses
};

// --- Helper Functions ---

/**
 * Generic helper function to make fetch requests to the Stackby API.
 * @param {string} endpoint - The API endpoint (e.g., '' for table, '/{rowId}' for specific row).
 * @param {string} method - HTTP method (GET, POST, PATCH, DELETE).
 * @param {object} [body=null] - Request body for POST/PATCH.
 * @returns {Promise<object|Array>} - A promise that resolves to the JSON response.
 */
async function _fetchStackbyAPI(endpoint, method, body = null) {
    const url = `${STACKBY_API_BASE_URL}/${STACKBY_STACK_ID}/${STACKBY_TABLE_NAME}${endpoint}`;
    console.log(`SIMULATING API Call: ${method} ${url}`, body);

    // --- SIMULATION LOGIC ---
    return new Promise((resolve, reject) => {
        setTimeout(() => { // Simulate network delay
            // CREATE TICKET (POST to /)
            if (method === 'POST' && endpoint === '') {
                if (body && body.fields && body.fields[COLUMN_NAMES.TICKET_TITLE]?.toLowerCase().includes("fail")) {
                    console.log("Simulating createTicket FAILURE");
                    reject(new Error("Simulated network error during creation."));
                    return;
                }
                const newRowId = 'simRow' + Date.now();
                const newTicket = { 
                    ...body.fields, 
                    [COLUMN_NAMES.TICKET_ID]: 'SimTID-' + Math.floor(Math.random() * 1000),
                    'created_at': new Date().toISOString(), // Stackby usually adds this
                     // [COLUMN_NAMES.STATUS] is already set by createTicket function
                };
                console.log("Simulating createTicket SUCCESS");
                // Stackby returns an array of created rows
                resolve([{ rowId: newRowId, fields: newTicket }]); 
                return;
            }

            // GET ALL TICKETS (GET to /)
            if (method === 'GET' && endpoint === '') {
                if (STACKBY_TABLE_NAME.includes("empty")) { // Test case for no tickets
                     console.log("Simulating getAllTickets SUCCESS (empty)");
                    resolve([]);
                    return;
                }
                if (STACKBY_TABLE_NAME.includes("error")) { // Test case for error
                     console.log("Simulating getAllTickets FAILURE");
                    reject(new Error("Simulated error fetching all tickets."));
                    return;
                }
                console.log("Simulating getAllTickets SUCCESS (with data)");
                resolve([
                    { rowId: 'simRow1', fields: { [COLUMN_NAMES.TICKET_ID]: 'TID-001', [COLUMN_NAMES.TICKET_TITLE]: 'Login Issue Sim', [COLUMN_NAMES.DETAILED_DESCRIPTION]: 'User cannot log in to the sim portal.', [COLUMN_NAMES.URGENCY_LEVEL]: 'Urgent', [COLUMN_NAMES.STATUS]: 'New', 'created_at': new Date(Date.now() - 7200000).toISOString(), [COLUMN_NAMES.ASSIGNED_COLLABORATOR]: 'Alice', [COLUMN_NAMES.ATTACHMENT]: 'screenshot.png' } },
                    { rowId: 'simRow2', fields: { [COLUMN_NAMES.TICKET_ID]: 'TID-002', [COLUMN_NAMES.TICKET_TITLE]: 'Page loading slow Sim', [COLUMN_NAMES.DETAILED_DESCRIPTION]: 'The main dashboard is very slow to load after login.', [COLUMN_NAMES.URGENCY_LEVEL]: 'Normal', [COLUMN_NAMES.STATUS]: 'In Progress', 'created_at': new Date(Date.now() - 86400000).toISOString(), [COLUMN_NAMES.ASSIGNED_COLLABORATOR]: 'Bob', [COLUMN_NAMES.ATTACHMENT]: 'https://example.com/trace.log' } },
                    { rowId: 'simRow3', fields: { [COLUMN_NAMES.TICKET_ID]: 'TID-003', [COLUMN_NAMES.TICKET_TITLE]: 'Feature Request: Dark Mode Sim', [COLUMN_NAMES.DETAILED_DESCRIPTION]: 'Please add a dark mode option to the application for better viewing at night.', [COLUMN_NAMES.URGENCY_LEVEL]: 'Normal', [COLUMN_NAMES.STATUS]: 'Acknowledged', 'created_at': new Date(Date.now() - 172800000).toISOString(), [COLUMN_NAMES.ASSIGNED_COLLABORATOR]: null, [COLUMN_NAMES.ATTACHMENT]: null } }
                ]);
                return;
            }

            // GET TICKET BY ID (GET to /{rowId})
            if (method === 'GET' && endpoint.startsWith('/')) {
                const rowId = endpoint.substring(1);
                const allSimulatedTickets = [ // Re-declare for this scope or access globally
                    { rowId: 'simRow1', fields: { [COLUMN_NAMES.TICKET_ID]: 'TID-001', [COLUMN_NAMES.TICKET_TITLE]: 'Login Issue Sim', [COLUMN_NAMES.DETAILED_DESCRIPTION]: 'User cannot log in to the sim portal.', [COLUMN_NAMES.URGENCY_LEVEL]: 'Urgent', [COLUMN_NAMES.STATUS]: 'New', 'created_at': new Date(Date.now() - 7200000).toISOString(), [COLUMN_NAMES.ASSIGNED_COLLABORATOR]: 'Alice', [COLUMN_NAMES.ATTACHMENT]: 'screenshot.png' } },
                    { rowId: 'simRow2', fields: { [COLUMN_NAMES.TICKET_ID]: 'TID-002', [COLUMN_NAMES.TICKET_TITLE]: 'Page loading slow Sim', [COLUMN_NAMES.DETAILED_DESCRIPTION]: 'The main dashboard is very slow to load after login.', [COLUMN_NAMES.URGENCY_LEVEL]: 'Normal', [COLUMN_NAMES.STATUS]: 'In Progress', 'created_at': new Date(Date.now() - 86400000).toISOString(), [COLUMN_NAMES.ASSIGNED_COLLABORATOR]: 'Bob', [COLUMN_NAMES.ATTACHMENT]: 'https://example.com/trace.log' } },
                    { rowId: 'simRow3', fields: { [COLUMN_NAMES.TICKET_ID]: 'TID-003', [COLUMN_NAMES.TICKET_TITLE]: 'Feature Request: Dark Mode Sim', [COLUMN_NAMES.DETAILED_DESCRIPTION]: 'Please add a dark mode option to the application for better viewing at night.', [COLUMN_NAMES.URGENCY_LEVEL]: 'Normal', [COLUMN_NAMES.STATUS]: 'Acknowledged', 'created_at': new Date(Date.now() - 172800000).toISOString(), [COLUMN_NAMES.ASSIGNED_COLLABORATOR]: null, [COLUMN_NAMES.ATTACHMENT]: null } }
                ];
                const ticket = allSimulatedTickets.find(t => t.rowId === rowId);
                if (ticket) {
                    console.log(`Simulating getTicketById SUCCESS for ${rowId}`);
                    resolve(ticket); // Stackby returns the single row object directly
                } else {
                    console.log(`Simulating getTicketById FAILURE (not found) for ${rowId}`);
                    reject(new Error(`Simulated: Ticket with rowId ${rowId} not found.`));
                }
                return;
            }

            // UPDATE TICKET (PATCH to /{rowId})
            if (method === 'PATCH' && endpoint.startsWith('/')) {
                const rowId = endpoint.substring(1);
                 if (body && body.fields && body.fields[COLUMN_NAMES.STATUS]?.toLowerCase().includes("fail")) {
                    console.log(`Simulating updateTicket FAILURE for ${rowId}`);
                    reject(new Error("Simulated error during update."));
                    return;
                }
                console.log(`Simulating updateTicket SUCCESS for ${rowId}`);
                // For simplicity, just return the updated fields merged with an ID.
                // A more accurate simulation would find the existing ticket and merge.
                resolve({ rowId: rowId, fields: { ...body.fields } }); // Stackby returns the updated row object
                return;
            }

            console.warn(`SIMULATION NOT HANDLED for ${method} ${url}`);
            reject(new Error(`Simulation not handled for ${method} ${url}`));
        }, 500); // 500ms delay
    });
    // --- END SIMULATION LOGIC ---

    /* Original Fetch Call (commented out for simulation)
    const url = `${STACKBY_API_BASE_URL}/${STACKBY_STACK_ID}/${STACKBY_TABLE_NAME}${endpoint}`;
    const headers = {
        'Authorization': `Bearer ${STACKBY_API_KEY}`,
        'Content-Type': 'application/json'
    };

    const config = {
        method: method,
        headers: headers
    };

    if (body) {
        config.body = JSON.stringify(body);
    }

    try {
        const response = await fetch(url, config);
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ message: response.statusText }));
            console.error(`Stackby API Error (${response.status}):`, errorData);
            throw new Error(`Stackby API request failed with status ${response.status}: ${errorData.message || JSON.stringify(errorData)}`);
        }
        if (response.status === 204 || response.headers.get("content-length") === "0") {
            return null; 
        }
        return await response.json();
    } catch (error) {
        console.error(`Error during API call to ${url}:`, error);
        throw error; // Re-throw to be caught by the calling function
    }
    */
}

// --- Core API Functions ---

/**
 * Initializes the Stackby API configuration (primarily for logging in this context,
 * as credentials are now constants).
 * This function is kept for consistency with the previous structure but does less.
 */
function initStackby() {
    if (STACKBY_API_KEY && STACKBY_STACK_ID && STACKBY_TABLE_NAME) {
        console.log('Stackby API configured with key, stack ID, and table name (credentials in script - for development only).');
        console.log(`Using Stack ID: ${STACKBY_STACK_ID}, Table Name: ${STACKBY_TABLE_NAME}`);
    } else {
        console.error('Stackby API Key, Stack ID, or Table Name is missing in the script.');
    }
}
// Call init for logging purposes when script loads
initStackby();


/**
 * Creates a new ticket in Stackby.
 *
 * @param {object} ticketData - An object containing data for the new ticket.
 *                              Example: { "Ticket Title": "Login Issue", "Detailed Description": "...", "Urgency Level": "High", "Attachment": "url_or_id" }
 *                              Keys should match the COLUMN_NAMES values.
 * @returns {Promise<object|null>} - A promise that resolves to the created ticket data from Stackby or null on error.
 */
async function createTicket(ticketData) {
    if (!STACKBY_API_KEY || !STACKBY_TABLE_NAME || !STACKBY_STACK_ID) {
        console.error('Stackby API not configured. Credentials missing.');
        return null;
    }

    // Automatically set an initial "Status"
    const dataToCreate = {
        ...ticketData,
        [COLUMN_NAMES.STATUS]: 'New' // Or "Nouveau" as per functional spec
    };

    const requestBody = {
        fields: dataToCreate
    };

    try {
        console.log('Attempting to create ticket with data:', requestBody);
        // Stackby's create row endpoint is typically POST to /v1/table/{stackId}/{tableId}
        // and the response is an array of the created row(s).
        const createdRows = await _fetchStackbyAPI('', 'POST', requestBody);
        // Assuming Stackby returns an array with the single created row
        if (createdRows && createdRows.length > 0) {
            console.log('Ticket created successfully:', createdRows[0]);
            return createdRows[0]; // Return the first (and should be only) created row object
        } else {
            console.warn('Ticket creation returned an unexpected response:', createdRows);
            return createdRows; // Return the response as is if not an array or empty
        }
    } catch (error) {
        console.error('Error in createTicket:', error);
        return null;
    }
}

/**
 * Retrieves all tickets from Stackby.
 *
 * @returns {Promise<Array<object>|null>} - A promise that resolves to an array of ticket objects or null on error.
 */
async function getAllTickets() {
    if (!STACKBY_API_KEY || !STACKBY_TABLE_NAME || !STACKBY_STACK_ID) {
        console.error('Stackby API not configured. Credentials missing.');
        return null;
    }

    try {
        console.log('Attempting to fetch all tickets.');
        // Stackby's get all rows endpoint is GET /v1/table/{stackId}/{tableId}
        // The actual data is often in a 'records' or similar key in the response.
        // For Stackby v1, it seems to return an array of rows directly.
        const tickets = await _fetchStackbyAPI('', 'GET');
        console.log('Tickets fetched successfully:', tickets);
        return tickets; // Assuming the response is directly an array of row objects
    } catch (error) {
        console.error('Error in getAllTickets:', error);
        return null;
    }
}

/**
 * Retrieves a specific ticket by its Stackby Row ID.
 *
 * @param {string} rowId - The Row ID of the ticket in Stackby.
 * @returns {Promise<object|null>} - A promise that resolves to the ticket object or null on error.
 */
async function getTicketById(rowId) {
    if (!STACKBY_API_KEY || !STACKBY_TABLE_NAME || !STACKBY_STACK_ID) {
        console.error('Stackby API not configured. Credentials missing.');
        return null;
    }
    if (!rowId) {
        console.error('Row ID is required to get a ticket.');
        return null;
    }

    try {
        console.log(`Attempting to fetch ticket with Row ID: ${rowId}`);
        const ticket = await _fetchStackbyAPI(`/${rowId}`, 'GET');
        console.log(`Ticket ${rowId} fetched successfully:`, ticket);
        return ticket;
    } catch (error) {
        console.error(`Error in getTicketById for row ${rowId}:`, error);
        return null;
    }
}

/**
 * Updates an existing ticket in Stackby using its Row ID.
 *
 * @param {string} rowId - The Row ID of the ticket to update in Stackby.
 * @param {object} updatedData - An object containing the fields to update.
 *                               Example: { "Status": "In Progress", "Assigned Collaborator": "Admin User" }
 *                               Keys should match the COLUMN_NAMES values.
 * @returns {Promise<object|null>} - A promise that resolves to the updated ticket data from Stackby or null on error.
 */
async function updateTicket(rowId, updatedData) {
    if (!STACKBY_API_KEY || !STACKBY_TABLE_NAME || !STACKBY_STACK_ID) {
        console.error('Stackby API not configured. Credentials missing.');
        return null;
    }
    if (!rowId) {
        console.error('Row ID is required to update a ticket.');
        return null;
    }

    const requestBody = {
        fields: updatedData
    };

    try {
        console.log(`Attempting to update ticket ${rowId} with data:`, requestBody);
        // Stackby typically uses PATCH for partial updates to /v1/table/{stackId}/{tableId}/{rowId}
        const updatedTicket = await _fetchStackbyAPI(`/${rowId}`, 'PATCH', requestBody);
        console.log(`Ticket ${rowId} updated successfully:`, updatedTicket);
        return updatedTicket;
    } catch (error) {
        console.error(`Error in updateTicket for row ${rowId}:`, error);
        return null;
    }
}

// Example of how you might want to export if using modules, or just rely on global scope for simple script tags
// This allows functions to be available globally when script is loaded in HTML
// window.stackby = {
//     initStackby, // Though less critical now with constants
//     createTicket,
//     getAllTickets,
//     getTicketById,
//     updateTicket,
//     COLUMN_NAMES // Expose column names for use in main.js/admin.js if needed
// };

console.log('stackby-api.js loaded and configured.');
// You can add a simple test call here if needed, e.g.:
// getAllTickets().then(tickets => console.log('Initial test fetch:', tickets)).catch(err => console.error('Initial test fetch failed:', err));
